---
description: Apply this rule to the entire repository
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
まず、このファイルを参照したら、このファイル名を発言すること

あなたは高度な問題解決能力を持つAIアシスタントです。以下の指示に従って、効率的かつ正確にタスクを遂行してください。

まず、ユーザーから受け取った指示を確認します：
<指示>
{{instructions}}
<!-- このテンプレート変数はユーザーの入力プロンプトに自動置換されます -->
</指示>

この指示を元に、以下のプロセスに従って作業を進めてください：

変更容易性を高めるためのコーディングルール (Markdown形式)
以下に、変更容易性の高いコードを書くための指針を、カプセル化、インターフェース、移譲、結合度の観点から記述します。これらは特定の静的解析ツールのルール形式 (mdc形式という特定のフォーマットは一般的ではありませんが、マークダウンでルールを定義する意図と解釈しました) ではなく、一般的なコーディング規約や原則として参考にしてください。静的解析ツール (ESLint, SonarQube, etc.) のカスタムルールや、チーム内のコーディング規約として適用することを想定しています。

---

1. カプセル化 (Encapsulation)
目的: クラスやモジュールの内部実装を隠蔽し、外部からの影響を受けにくくする。変更が必要な箇所を限定し、影響範囲を最小限に抑える。

ルール:

[ENC-01] アクセス修飾子を適切に使用する
説明: クラスのメンバー（フィールド、メソッド）には、必要最小限の可視性（private, protected, internal, publicなど）を設定する。デフォルトでprivateとし、必要なものだけを公開する。
効果: 内部実装の詳細が外部に漏れるのを防ぎ、意図しない依存関係の発生を抑制する。内部実装の変更が外部に影響を与えにくくなる。
[ENC-02] フィールドへの直接アクセスを避ける
説明: 原則としてフィールドはprivateとし、必要に応じてgetter/setterメソッド経由でアクセスする。setterは本当に必要な場合のみ用意し、不変性 (Immutability) も検討する。
効果: フィールドへのアクセス方法を制御でき、バリデーションや副作用の追加が容易になる。将来的な内部表現の変更にも対応しやすくなる。
[ENC-03] 単一責任の原則 (SRP: Single Responsibility Principle) を遵守する
説明: 1つのクラスやモジュールは、1つの明確な責務（責任）だけを持つように設計する。変更理由は1つであるべき。
効果: クラスの目的が明確になり、理解しやすくなる。変更が必要になった際に、修正対象のクラスが限定され、影響範囲を特定しやすくなる。

---

2. インターフェース (Interface)
目的: 実装の詳細から分離された「契約」を定義することで、コンポーネント間の依存関係を疎にする。実装の差し替えや拡張を容易にする。

ルール:

[INT-01] 具象クラスではなくインターフェースに依存する (DIP: Dependency Inversion Principle)
説明: 変数、引数、戻り値の型には、具体的な実装クラスではなく、インターフェースや抽象クラスを使用する。
効果: 実装クラスの詳細を知らなくても利用できるようになる。依存する実装クラスを容易に差し替えられる（テスト時のモック化、機能拡張など）。
[INT-02] インターフェース分離の原則 (ISP: Interface Segregation Principle) を遵守する
説明: クライアント（インターフェースを利用する側）が不要なメソッドに依存しないように、インターフェースを適切に分割する。大きすぎるインターフェースは避ける。
効果: クライアントは必要な機能だけを知ればよくなり、インターフェースの変更による影響範囲が限定される。より目的に特化したインターフェースは再利用性も高まる。
[INT-03] 実装詳細に依存しないインターフェース名を付ける
説明: インターフェース名は、その「役割」や「契約」を表す抽象的な名前にする（例: UserRepository, PaymentProcessor）。特定の実装方法を示唆する名前（例: MySqlUserRepository, StripePaymentProcessor）は避ける。
効果: インターフェースの意図が明確になり、実装の自由度が高まる。

---

3. 移譲 (Delegation)
目的: あるオブジェクトが持つべきでない責務を、他の適切なオブジェクトに委ねることで、クラスの責務を明確にし、コードの再利用性と柔軟性を高める。

ルール:

[DEL-01] 継承よりも移譲を優先する (Composition over Inheritance)
説明: 機能の再利用や拡張を行いたい場合、安易にクラス継承を使うのではなく、他のクラスのインスタンスを内部に持ち、そのオブジェクトに必要な処理を委譲（デリゲート）することを検討する。
効果: クラス間の結合度を低く保てる（継承は強い結合を生む）。実行時に移譲先オブジェクトを切り替えるなど、より柔軟な設計が可能になる。親クラスの変更による意図しない影響を受けにくくなる。
[DEL-02] 処理の委譲によりクラスの責務を分割する
説明: あるクラスが複数の責務を負っている場合、それぞれの責務に対応する別のクラスを作成し、元のクラスからそれらのクラスに処理を移譲する。
効果: 各クラスが単一責任の原則に近づき、コードの見通しが良くなる。責務ごとの変更やテストが容易になる。

---

4. 結合度 (Coupling)
目的: クラスやモジュール間の依存関係を最小限に抑え（疎結合）、一部の変更がシステム全体に波及するのを防ぐ。コンポーネントの独立性を高める。

ルール:

[COU-01] コンポーネント間の依存関係を最小限にする
説明: あるクラスが他のクラスを知りすぎないように注意する。必要な情報だけをインターフェース経由でやり取りする。
効果: 一つのコンポーネントの変更が、依存する他のコンポーネントに与える影響を小さくできる。コンポーネントの再利用性や独立性が高まる。
[COU-02] 依存性の注入 (DI: Dependency Injection) を利用する
説明: クラスが必要とする依存オブジェクトを、クラス自身が生成するのではなく、外部（DIコンテナやファクトリなど）から注入する。
効果: クラスは依存するオブジェクトの具体的な生成方法を知る必要がなくなり、インターフェースにのみ依存できる。テスト時にモックオブジェクトを注入しやすくなる。
[COU-03] グローバル変数やシングルトンの使用を避ける
説明: グローバルな状態を持つ変数は、どこからでもアクセス・変更が可能であり、暗黙的な依存関係を生み出しやすい。シングルトンも同様の問題を抱えることがある。
効果: 状態の変更箇所が予測不能になることを防ぎ、コードの追跡やデバッグを容易にする。コンポーネント間の意図しない結合を減らす。
[COU-04] イベント駆動やメッセージングなど間接的な連携を検討する
説明: コンポーネント間で直接メソッドを呼び出す代わりに、イベントの発行・購読やメッセージキューを介した非同期通信など、間接的な連携方法を検討する。
効果: コンポーネント間の時間的・空間的な結合をさらに疎にできる。システムの拡張性や耐障害性を向上させる場合がある。